/**
 * Wingspan Simulator - Event Taxonomy
 *
 * Events are semantic notifications emitted by the GameEngine to any GameObservers + dependent classes (e.g. PowerProcessor).
 *
 * They serve three purposes:
 * 1. Trigger bird power activations via the PowerProcessor (white/brown powers for the active player)
 * 2. Trigger reactive bird powers via the PowerProcessor (pink powers across players)
 * 3. Provide high-level rendering/logging/replay hooks for GameObservers
 *
 * DESIGN PRINCIPLES:
 * - Events are ONLY emitted for: lifecycle moments, player actions, and pink power triggers (derived from effects)
 * - Effects that don't trigger pink powers don't generate events (observers can see effects directly if needed)
 */

import type {
  PlayerId,
  BirdInstanceId,
  BirdCardId,
  Habitat,
  FoodType,
  FoodByType,
  DieFace,
} from "./core.ts";

/**
 * All possible events that can be emitted by the GameEngine.
 * These are placed in the internal event queue and processed synchronously.
 */
export type Event = LifecycleEvent | ActionEvent | PinkPowerTriggerEvent;

/**
 * Boundary events emitted by the GameEngine.
 * None of these trigger bird powers in the base game, but can in expansions.
 */
export type LifecycleEvent =
  | GameStartedEvent
  | RoundStartedEvent
  | RoundEndedEvent
  | TurnStartedEvent
  | TurnEndedEvent
  | PlayerForfeitedEvent
  | GameEndedEvent;

/**
 * Encompasses the four high-level actions a player can take on their turn
 * These can trigger both white and brown powers
 */
export type ActionEvent = HabitatActivatedEvent | BirdPlayedEvent;

/**
 * Events that trigger reactive pink powers in between turns for non-active players
 */
export type PinkPowerTriggerEvent =
  | FoodGainedFromHabitatActivationEvent
  | EggsLaidFromHabitatActivationEvent
  | PredatorPowerResolvedEvent
  // Playing a bird is both an ActionEvent and a PinkPowerTriggerEvent
  | BirdPlayedEvent;

interface EventBase {
  /**
   * Unique identifier for this event instance.
   * Useful for debugging and replay systems.
   */
  eventId?: string;

  /**
   * Timestamp when the event was created.
   * Useful for debugging and replay systems.
   */
  timestamp?: number;
}

/**
 * Emitted when the game starts (after setup is complete).
 */
export interface GameStartedEvent extends EventBase {
  type: "GAME_STARTED";
  playerIds: PlayerId[];
  seed: number;
}

/**
 * Emitted at the start of each round.
 */
export interface RoundStartedEvent extends EventBase {
  type: "ROUND_STARTED";
  round: number; // 1-4
}

/**
 * Emitted at the end of each round (after end-of-round goal scoring).
 */
export interface RoundEndedEvent extends EventBase {
  type: "ROUND_ENDED";
  round: number; // 1-4
}

/**
 * Emitted at the start of a player's turn.
 */
export interface TurnStartedEvent extends EventBase {
  type: "TURN_STARTED";
  playerId: PlayerId;
  round: number;
  turnNumber: number; // Global turn counter
}

/**
 * Emitted at the end of a player's turn (after all actions and reactions complete).
 */
export interface TurnEndedEvent extends EventBase {
  type: "TURN_ENDED";
  playerId: PlayerId;
}

/**
 * Emitted when the game ends (after final scoring).
 */
export interface GameEndedEvent extends EventBase {
  type: "GAME_ENDED";
  finalScores: Record<PlayerId, number>;
  winnerId: PlayerId;
}

/**
 * Emitted when a player forfeits due to repeated invalid choices.
 * In 2-player games, this ends the game.
 * In 3+ player games, the game continues with remaining players.
 */
export interface PlayerForfeitedEvent extends EventBase {
  type: "PLAYER_FORFEITED";
  /** The player who forfeited */
  playerId: PlayerId;
  /** The reason for forfeit (from the validation error) */
  reason: string;
  /** Number of active players remaining after this forfeit */
  remainingPlayerCount: number;
}

/**
 * Emitted when a player activates a habitat row.
 * This is the primary trigger for brown "when activated" powers.
 *
 * TRIGGERS: Brown powers in the activated habitat (processed right-to-left)
 * RENDERING: Observers can show which habitat is being activated
 * GENERATED BY: GameEngine after applying the "activate habitat" action
 *
 * IMPORTANT: This event is generated BEFORE brown powers are resolved.
 * The PowerProcessor listens for this event and resolves each brown power in sequence.
 * Each brown power's effects will generate their own events (e.g., FoodGainedEvent).
 */
export interface HabitatActivatedEvent extends EventBase {
  type: "HABITAT_ACTIVATED";
  playerId: PlayerId;
  habitat: Habitat;

  /**
   * The bird instances in this habitat that have brown powers, in activation order (right-to-left).
   * This allows the PowerProcessor to activate them in sequence.
   */
  brownPowerBirdInstanceIds: BirdInstanceId[];
}

/**
 * Emitted when a bird is played to a habitat.
 *
 * TRIGGERS:
 * - "When played" white powers on the bird itself
 * - Pink powers that react to bird plays (e.g. Belted Kingfisher, Eastern Kingbird, Horned Lark)
 *
 * POWER ACTIVATION ORDER:
 * 1. This event is emitted
 * 2. Check for "when played" white powers on the played bird itself
 * 3. Check for pink powers on other players' birds
 *
 * RECURSIVE BIRD PLAYS:
 * Some white powers allow playing additional birds (e.g., "When played, play another bird").
 * This creates a recursive flow:
 *   PlayBirdEffect (Bird A) → BirdPlayedEvent (Bird A) → White power triggers →
 *   PlayBirdEffect (Bird B) → BirdPlayedEvent (Bird B) → ...
 *
 * This is intentional and bounded. The recursion terminates when:
 * - The white power doesn't trigger another bird play
 * - The player runs out of resources
 * - The habitat is full
 */
export interface BirdPlayedEvent extends EventBase {
  type: "BIRD_PLAYED";
  playerId: PlayerId;

  /**
   * The runtime instance ID of the bird.
   */
  birdInstanceId: BirdInstanceId;

  /**
   * The card definition ID (for looking up bird details).
   */
  birdCardId: BirdCardId;

  /**
   * Which habitat the bird was played to.
   */
  habitat: Habitat;

  /**
   * The position in the habitat (0 = leftmost).
   */
  position: number;
}

/**
 * Emitted when a player takes the "gain food" action.
 *
 * TRIGGERS: Pink powers that react to "takes the gain food action" (e.g. Loggerhead Shrike)
 */
export interface FoodGainedFromHabitatActivationEvent extends EventBase {
  type: "FOOD_GAINED_FROM_HABITAT_ACTIVATION";
  playerId: PlayerId;
  food: FoodByType;
}

/**
 * Emitted when a player takes the "lay eggs" action.
 *
 * TRIGGERS: Pink powers that react to "takes the lay eggs action" (e.g. American Avocet, Barrow's Goldeneye, Bronzed Cowbird, Brown-Headed Cowbird, Yellow-Billed Cuckoo)
 */
export interface EggsLaidFromHabitatActivationEvent extends EventBase {
  type: "EGGS_LAID_FROM_HABITAT_ACTIVATION";
  playerId: PlayerId;
  /**
   * Which birds received eggs, and how many each.
   * Example: [{ birdInstanceId: "bird-123", count: 2 }, { birdInstanceId: "bird-456", count: 1 }]
   */
  placements: Array<{
    birdInstanceId: BirdInstanceId;
    count: number;
  }>;
}

/**
 * Emitted when a predator power resolves (success or failure).
 *
 * TRIGGERS: Pink powers that react to predator success (e.g. Turkey Vulture, Black Vulture, Black-Billed Magpie)
 */
export interface PredatorPowerResolvedEvent extends EventBase {
  type: "PREDATOR_POWER_RESOLVED";
  playerId: PlayerId;

  /**
   * The predator bird that activated.
   */
  predatorBirdInstanceId: BirdInstanceId;

  /**
   * Whether the predator power succeeded.
   */
  success: boolean;

  /**
   * The type of predator power.
   */
  predatorType: "WINGSPAN_CHECK" | "DICE_ROLL";

  /**
   * Details for wingspan check predators.
   * Only present if predatorType === "WINGSPAN_CHECK".
   */
  wingspanCheck?: {
    /**
     * The card that was revealed (for rendering).
     * NOTE: This is public information once revealed.
     */
    revealedCardId: BirdCardId;

    /**
     * The wingspan of the revealed card.
     */
    wingspan: number;

    /**
     * The wingspan threshold for success.
     */
    threshold: number;

    /**
     * What happened to the revealed card.
     */
    disposition: "TUCKED" | "DISCARDED";
  };

  /**
   * Details for dice roll predators.
   * Only present if predatorType === "DICE_ROLL".
   */
  diceRoll?: {
    /**
     * The dice that were rolled (die faces showing on each die).
     */
    diceRolled: DieFace[];

    /**
     * The food type the predator was looking for.
     */
    targetFoodType: FoodType;

    /**
     * How many matching dice were rolled.
     */
    matchCount: number;

    /**
     * The food that was cached (if success).
     * Only present if success === true.
     */
    cachedFood?: FoodType;
  };
}

// ============================================================================
// Event Notes
// ============================================================================

/**
 * OBSERVERS AND EFFECTS:
 * Observers that want to see detailed state changes (like card tucks or food caches) can
 * subscribe to `onEffectApplied()`. Events are reserved for semantic moments and power triggers.
 */

/**
 * PlayerAgents can OPTIONALLY implement GameObserver to read the event stream.
 * This is especially useful for AI agents (e.g., LLM agents) that benefit from
 * seeing a narrative of what happened, rather than just state diffs.
 *
 * Example:
 *
 * class LLMPlayerAgent implements PlayerAgent, GameObserver {
 *   private eventLog: Event[] = [];
 *
 *   // GameObserver implementation
 *   onEventProcessing(event: Event): void {
 *     this.eventLog.push(event);
 *   }
 *
 *   // PlayerAgent implementation
 *   async chooseAction(view: PlayerView, options: Action[]): Promise<Action> {
 *     // Build LLM prompt from event log
 *     const narrative = this.buildNarrative(this.eventLog);
 *     const decision = await this.llm.decide(narrative, view, options);
 *
 *     // Clear log after turn
 *     this.eventLog = [];
 *     return decision;
 *   }
 *
 *   private buildNarrative(events: Event[]): string {
 *     return events.map(e => {
 *       switch (e.type) {
 *         case "BIRD_PLAYED":
 *           return `${e.playerId} played a bird in ${e.habitat}`;
 *         case "FOOD_GAINED":
 *           return `${e.playerId} gained ${Object.entries(e.food).map(([t, c]) => `${c} ${t}`).join(", ")}`;
 *         // ... other event types
 *       }
 *     }).join("\n");
 *   }
 * }
 */

/**
 * EVENT QUEUE PROCESSING (Synchronous):
 *
 * 1. Player takes an action (e.g., "activate forest habitat")
 * 2. Engine applies base action effects
 * 3. Engine generates events from those effects
 * 4. Engine enqueues events
 * 5. Engine processes event queue:
 *    a. Dequeue event
 *    b. Notify observers (onEventProcessing)
 *    c. PowerProcessor resolves any triggered powers
 *    d. Engine applies effects from those powers
 *    e. Engine generates new events from those effects
 *    f. Engine enqueues new events
 *    g. Notify observers (onEventProcessed)
 *    h. Repeat until queue is empty
 *
 * EXAMPLE: Turkey Vulture Pink Power
 *
 * 1. Player A activates forest habitat
 * 2. Player A's Barn Owl (predator) power activates
 * 3. RevealCardsEffect is applied (wingspan check succeeds)
 * 4. PredatorPowerResolvedEvent is generated and enqueued
 * 5. Engine processes PredatorPowerResolvedEvent:
 *    - PowerProcessor finds Player B's Turkey Vulture (pink power)
 *    - Player B chooses to activate Turkey Vulture
 *    - GainFoodEffect is generated for Player B
 * 6. Engine applies GainFoodEffect
 * 7. FoodGainedEvent is generated and enqueued
 * 8. Engine processes FoodGainedEvent:
 *    - No powers trigger on this
 * 9. Queue is empty, continue with Player A's next brown power
 *
 * This ensures that Player B's Turkey Vulture reaction is fully resolved
 * before Player A's next brown power activates.
 */

/**
 * RENDERING WITH EVENTS:
 *
 * Observers have two levels of detail:
 *
 * 1. HIGH-LEVEL (Events only):
 *    - onEventProcessing(event) → Show semantic game events
 *    - Example: "Player A's predator power succeeded!"
 *
 * 2. DETAILED (Events + Effects):
 *    - onEventProcessing(event) → Show semantic game events
 *    - onEffectApplied(effect) → Show state changes
 *    - Example: "Player A's predator power succeeded! Tucked 1 card. Player A gained 1 VP."
 *
 * This flexibility allows different rendering modes without changing the engine.
 */
